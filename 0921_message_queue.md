# 메시지 큐, 메시지 브로커

- **MOM (Message Oriented Middleware):** 메시지 미들웨어의 이론, 개념, 설계도를 의미



## 메시지 큐란?

서비스, 프로그램 및 운영체제 및 통신 프로토콜과 같은 이기종 구성요소 간의 통신을 가능하게 하기 위해 소프트웨어 개발에 사용되는 미들웨어



메세지를 보낼 때, 긴급하지 않은 경우 문자 메세지를 보낸다고 생각하자.

메세지는 수신자 전화기의 대기열에 들어가며, 가능한 경우 응답한다.



대기중인 메세지는 보통 작고 구체적이다.

요청, 응답, 오류 메세지 또는 로깅 추적에 필요하다.

생산자는 메세지를 만들고 소비자는 메세지를 처리한다.

A producer creates the message, and a consumer processes it.



소비자는 메시지를 처리하고 삭제할 수 있을 때까지 대기열(버퍼나 저장매체)에 메세지를 저장한다.

Consumers store messages in a queue — usually in a buffer or on a storage medium — until they can process and delete them.



주어진 소비자는 각 메세지를 한 번만 처리한다. 

A given consumer only processes each message once. 



처리량이 많은 기간 동안 메세지 큐를 사용하여 작업을 저장한다. 

메세지큐는 생산자와 소비자가 데이터 손실 없이 일관된 속도로 작업할 수 있도록 하여 급증하는 워크로드를 완화할 수 있다.



다음과 같은 대기열 소프트웨어 옵션을 사용한다.

아파치 카프카는 스트리밍 정보에 최적화된 오픈소스 분산 플랫폼이다.

### 

중간 노드에 메시지를 저장해서, 네트워크 정체가 심해도 빠르고 안정적으로 이메일 메시지를 처리할 수 있도록 한다. 



### 발행 및 구독(**Publish-and-subscribe** **messaging**)

- 소비자로부터 정보 제공자를 분리해서 둘 다 상대방에 대한 정보가 불필요하다. 
  - decouples the provider of the information from the consumer.
- 수신자는 송신자의 IP 주소나, 특별한 정보를 알 필요가 없이 원하는 주제만 사전에 구독 신청을 하면 된다. 따라 송수신자는 loosely coupled로 엮여있고 높은 확장성을 제공한다. 메시지 큐의 대다수의 구현체는 Pub/Sub 구조를 가지고 있다.
- 이메일 발신에서 사용하는  To:, CC:처럼 특정 수신자를 정하는 것이 아니라, Publlish 하는 토픽(Topic)을 구독(Subscriber) 신청한 모든 수신자에게 메시지를 보내는 방식이다. 



## 메시지 브로커란?

메시지 브로커는 메시지 큐에서 더 확장된 기능을 가진다.

더 광범위한 전송, 메세지 내용을 통한 라우팅 추가 및 고급 기능을 지원한다.

메세지를 보낸 사람의 형식 메시징 프로토콜에서 받는 사람의 형식 메시징 프로토콜로 변환하는 중간 컴퓨터 프로그래밍 모듈이다.

메시지 브로커를 사용하여 여러 수신자에 대한 워크로드 대기열 또는 메시지 대기열을 관련하여 안정적인 스토리지, 보장된 메세지 전달 및 트랜젝션 관리가 가능하다.



### 왜 쓸까? 의존성 제거

- 송신 측 서버가 문제가 생기면 송신 측 서버에 Request를 보내는 서버들도 또 비슷한 문제가 발생할 수 있습니다. 이를 장애 전파 라고 합니다. 이러한 장애전파를 막기 위해선 Circuit breaker, fall-back 등을 활용해야 합니다.

메시지 **브로커는 이러한 어플리케이션 의존성을 제거해줌으로써 앞선 문제들을 해결해주고 있습니다.**



![img](/Users/euijinpang/[git] dev-ops/0921_message_queue.assets/img.png)





### **메시지 브로커의 단점**

당연히도 단점이 존재합니다.

 

**Bottleneck point(병목현상 지점)**이 될 수 있습니다.

- 많은 고객 수로 인해 서버들이 확장(Scale-out)하는 상황에서 만약 메시지 브로커는 기존 수 그대로 남아있다면, 늘어난 고객 수 및 서버 수의 요청을 같은 수의 메시지 브로커로 감당하는 것이므로 당연히도 병목현상이 발생할 수 있습니다. 메시지 큐에 메시지가 쌓이면서 요청을 처리하는 속도가 느려질 수 있습니다.
- 하지만 최근 많은 메시지 브로커들이 확장이 가능한 구조로 설계되어 이러한 문제는 적어지고 있습니다. 서버 수의 증가에 따라 메시지 브로커의 수도 확장해나감으로서 문제를 해결할 수 있습니다.

